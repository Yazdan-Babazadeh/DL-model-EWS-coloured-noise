# -*- coding: utf-8 -*-
"""Plot 1 AI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17hTUq3ZKniepz0OIJkLKKtHo-1YuSWYI
"""

!pip install tensorflow==2.12.1

import numpy as np
from scipy.integrate import odeint
import random

def time_series(index,redness,on): #1:Trans, 2:Hopf, 3: fold # 4:Trans 5:Hopf 6:Fold
  if index == 1:
    T = 200
    dt = (10**-2)
    steps2= int(T/dt)

    r=4
    k=1.7
    e=0.5
    h=0.15

    m=2


    def X_trans_dot(x,y,a):
      a1 = r*x*(1-(x/k))
      b1 = (a*x*y)/(1+(a*h*x))
      return a1-b1
    def Y_trans_dot(x,y,a):
      a1 = (e*a*x*y)/(1+(a*h*x))
      b1 = m*y
      return a1-b1
    a = -2

    #for transcritical -2 to 6
    #for hopf 12 to 18
    X=np.zeros(steps2)
    Y = np.zeros(steps2)
    X[0]=2
    Y[0]=2
    for i in range(0,steps2-1):
      X[i+1] = X[i] + (X_trans_dot(X[i],Y[i],a))*dt
      Y[i+1] = Y[i] + (Y_trans_dot(X[i],Y[i],a))*dt
    #plt.plot(X)
    #plt.plot(Y)

    X2 = np.zeros(steps2)
    Y2 = np.zeros(steps2)
    if on == 1:
      da = (6-a)/(steps2) #9
    else:
      da = 0
    #bifurcation happens at a=5.6
    X2[0] = X[steps2-1]
    Y2[0] = Y[steps2-1]
    sigma = 0.01 #0.005
    Red_noise5 = np.zeros(steps2)
    Red_noise5[0] = random.gauss(0,1)
    for i in range(0,steps2-1):
      a = a + da
      X2[i+1] = X2[i] + (X_trans_dot(X2[i],Y2[i],a)*dt) + (sigma*np.sqrt(dt)*Red_noise5[i])
      Y2[i+1] = Y2[i] + (Y_trans_dot(X2[i],Y2[i],a)*dt) + (sigma*np.sqrt(dt)*Red_noise5[i])
      Red_noise5[i+1]= (redness*Red_noise5[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
    #X2 = 1-X2
    return X2
  elif index == 2:
    T = 200
    dt = (10**-2)
    steps2= int(T/dt)

    r=4
    k=1.7
    e=0.5
    h=0.15

    m=2
    redness = 0

    def X_trans_dot(x,y,a):
      a1 = r*x*(1-(x/k))
      b1 = (a*x*y)/(1+(a*h*x))
      return a1-b1
    def Y_trans_dot(x,y,a):
      a1 = (e*a*x*y)/(1+(a*h*x))
      b1 = m*y
      return a1-b1
    a = 9

    #for transcritical -2 to 6
    #for hopf 12 to 18
    X=np.zeros(steps2)
    Y = np.zeros(steps2)
    X[0]=2
    Y[0]=2
    for i in range(0,steps2-1):
      X[i+1] = X[i] + (X_trans_dot(X[i],Y[i],a))*dt
      Y[i+1] = Y[i] + (Y_trans_dot(X[i],Y[i],a))*dt
    #plt.plot(X)
    #plt.plot(Y)

    X2 = np.zeros(steps2)
    Y2 = np.zeros(steps2)
    if on == 1:
      da = (18-a)/(steps2) #9
    else:
      da = 0
    #bifurcation happens at a=5.6
    X2[0] = X[steps2-1]
    Y2[0] = Y[steps2-1]
    sigma = 0.01 #0.005
    Red_noise5 = np.zeros(steps2)
    Red_noise5[0] = random.gauss(0,1)
    for i in range(0,steps2-1):
      a = a + da
      X2[i+1] = X2[i] + (X_trans_dot(X2[i],Y2[i],a)*dt) + (sigma*np.sqrt(dt)*Red_noise5[i])
      Y2[i+1] = Y2[i] + (Y_trans_dot(X2[i],Y2[i],a)*dt) + (sigma*np.sqrt(dt)*Red_noise5[i])
      Red_noise5[i+1]= (redness*Red_noise5[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
    return X2
  elif index==3:

    T1 = 100
    dt1 = (10**-2)
    test_steps1= int(T1/dt1)
    steps2 = test_steps1

    def X_fold_dot(x,h):
      a = x*(1-x)
      b = h * ((x**2)/((x**2)+(0.01)))
      return a-b
    t1 = np.linspace(0,T1,test_steps1)
    x = odeint(X_fold_dot,random.uniform(15,20),t1)

    #plt.plot(x)
    h = 0.2   #0.1
    if on == 1:
      dh = (0.29-h)/test_steps1
    else :
      dh = 0
    #bifurcation happens at h=0.26

    #dh = (0.5-h)/(test_steps1)
    X_fold = np.zeros(test_steps1)
    #X_fold[0] = x[test_steps1-1]
    X_fold[0] = 0.7
    Red_noise = np.zeros(test_steps1)
    Red_noise[0] = random.gauss(0,1)
    for i in range(0,test_steps1-1):
      Red_noise[i+1]= (redness*Red_noise[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
      h = h + dh
      X_fold[i+1] = X_fold[i] + (X_fold_dot(X_fold[i],h)*dt1) + (0.005*np.sqrt(dt1)*random.gauss(0,1))#Red_noise[i+1]) #uused to be 0.01
    return X_fold

from google.colab import files
uploaded = files.upload()

from tensorflow.keras.models import load_model
model = load_model('Normal_form_CNN_LSTM_r=0.h5')

# Transcritical

X1 = time_series(1,0,1)
t11 = np.linspace(0,1,len(X1))

import statsmodels.api as sm
from scipy.ndimage import gaussian_filter1d
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from statsmodels.tsa.seasonal import seasonal_decompose
steps2 = len(X1)
steps = 1000
intervals = 400
sigmaa = 100
padding = 100
size = int(((steps2/steps)-1)*intervals)+1
Y = np.zeros((size,steps))
Y2 = np.zeros(steps+(2*padding))
t = np.zeros(size)
for i in range(0,size):
  j1=int(i*steps/intervals)
  j2 = j1+steps
  #j=i
  Y[i,:] = X1[j1:j2]
  #Y2[padding:steps+padding] = Y[i,:]
  #frac = 0.75
  Y[i,:] = Y[i,:]-(gaussian_filter1d(Y[i,:], sigmaa,mode = 'nearest'))
  #Y2[i,:] = Y[i,100:1100]
  #Y[i,:] = Y2[padding:steps+padding]
  Y[i,:] = (Y[i,:]-np.average(Y[i,:]))/(np.std(Y[i,:]))
  #Y2[i,:] = (Y2[i,:]-np.average(Y2[i,:]))/(np.std(Y2[i,:]))
  #smoothed = sm.nonparametric.lowess(Y[i,:], np.arange(len(Y[i,:])), frac=frac)
  #Y[i,:] = (Y[i,:]-smoothed[:,1])/(np.std(Y[i,:]-smoothed[:,1]))

np.shape(Y)
predict_x=model.predict(Y)
output=np.argmax(predict_x,axis=1)

import matplotlib.pyplot as plt
fold1_prob = predict_x[:,0]
#fold2_prob = predict_x[:,1]
Trans1_prob = predict_x[:,1]
#Trans2_prob = predict_x[:,3]
Hopf_prob = predict_x[:,2]
Null_prob = predict_x[:,3]
t= np.linspace(steps,steps2,size)
#t= t*50/size
plt.plot(t,fold1_prob,"r",label="fold")
#plt.plot(t,fold2_prob,"r",label="fold")
plt.plot(t,Trans1_prob,'g',label="trans1")
#plt.plot(t,Trans2_prob,'g',label="trans")
plt.plot(t,Hopf_prob,'y',label="Hopf")
plt.plot(t,Null_prob,'b',label="null")
#plt.plot(t,null_fold_prob,'y',label="Null_Fold")

plt.legend(loc="lower left")
plt.ylabel("DL Probability")
plt.xlabel("Time")
plt.axvline(x=0.7,color='black',ls='--', ymin=0,ymax=1,label='Alpha=0.55')

window_size = 50

Fold1 = np.convolve(fold1_prob, np.ones(window_size)/window_size, mode='valid')

Trans1 = np.convolve(Trans1_prob, np.ones(window_size)/window_size, mode='valid')
#Trans2_prob = np.convolve(Trans2_prob, np.ones(window_size)/window_size, mode='valid')
Hopf1 = np.convolve(Hopf_prob, np.ones(window_size)/window_size, mode='valid')
Null1 = np.convolve(Null_prob, np.ones(window_size)/window_size, mode='valid')

t12= np.linspace(0,1,np.size(Hopf1))
plt.plot(t12,Hopf1,"y",label="Hopf")
plt.plot(t12,Trans1,"g",label="Trans")
#plt.plot(t,Trans2_prob,"brown",label="Trans2")
plt.plot(t12,Fold1,'r',label="fold")
plt.plot(t12,Null1,'b',label="null")
#plt.legend(loc="lower left")
plt.ylabel("DL Probability")
plt.xlabel("Scaled Time")
plt.title("Van der Pol Oscillator - Hopf Bifurcation")
#plt.axvline(x=0.6,color='black',ls='--', ymin=0,ymax=1,label='Alpha=15.69')
plt.axvline(x=0.85,color='black',ls='--', ymin=0,ymax=1,label='Alpha=15.69')

# Hopf

X2 = time_series(2,0,1)
t21 = np.linspace(0,1,len(X2))

import statsmodels.api as sm
from scipy.ndimage import gaussian_filter1d
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from statsmodels.tsa.seasonal import seasonal_decompose
steps2 = len(X2)
steps = 1000
intervals = 400
sigmaa = 100
padding = 100
size = int(((steps2/steps)-1)*intervals)+1
Y = np.zeros((size,steps))
Y2 = np.zeros(steps+(2*padding))
t = np.zeros(size)
for i in range(0,size):
  j1=int(i*steps/intervals)
  j2 = j1+steps
  #j=i
  Y[i,:] = X2[j1:j2]
  #Y2[padding:steps+padding] = Y[i,:]
  #frac = 0.75
  Y[i,:] = Y[i,:]-(gaussian_filter1d(Y[i,:], sigmaa,mode = 'nearest'))
  #Y2[i,:] = Y[i,100:1100]
  #Y[i,:] = Y2[padding:steps+padding]
  Y[i,:] = (Y[i,:]-np.average(Y[i,:]))/(np.std(Y[i,:]))
  #Y2[i,:] = (Y2[i,:]-np.average(Y2[i,:]))/(np.std(Y2[i,:]))
  #smoothed = sm.nonparametric.lowess(Y[i,:], np.arange(len(Y[i,:])), frac=frac)
  #Y[i,:] = (Y[i,:]-smoothed[:,1])/(np.std(Y[i,:]-smoothed[:,1]))

np.shape(Y)
predict_x=model.predict(Y)
output=np.argmax(predict_x,axis=1)

import matplotlib.pyplot as plt
fold1_prob = predict_x[:,0]
#fold2_prob = predict_x[:,1]
Trans1_prob = predict_x[:,1]
#Trans2_prob = predict_x[:,3]
Hopf_prob = predict_x[:,2]
Null_prob = predict_x[:,3]
t= np.linspace(steps,steps2,size)
#t= t*50/size
plt.plot(t,fold1_prob,"r",label="fold")
#plt.plot(t,fold2_prob,"r",label="fold")
plt.plot(t,Trans1_prob,'g',label="trans1")
#plt.plot(t,Trans2_prob,'g',label="trans")
plt.plot(t,Hopf_prob,'y',label="Hopf")
plt.plot(t,Null_prob,'b',label="null")
#plt.plot(t,null_fold_prob,'y',label="Null_Fold")

plt.legend(loc="lower left")
plt.ylabel("DL Probability")
plt.xlabel("Time")
plt.axvline(x=0.7,color='black',ls='--', ymin=0,ymax=1,label='Alpha=0.55')

window_size = 50

Fold2 = np.convolve(fold1_prob, np.ones(window_size)/window_size, mode='valid')

Trans2 = np.convolve(Trans1_prob, np.ones(window_size)/window_size, mode='valid')
#Trans2_prob = np.convolve(Trans2_prob, np.ones(window_size)/window_size, mode='valid')
Hopf2 = np.convolve(Hopf_prob, np.ones(window_size)/window_size, mode='valid')
Null2 = np.convolve(Null_prob, np.ones(window_size)/window_size, mode='valid')

t22= np.linspace(0,1,np.size(Hopf2))
plt.plot(t22,Hopf2,"y",label="Hopf")
plt.plot(t22,Trans2,"g",label="Trans")
#plt.plot(t,Trans2_prob,"brown",label="Trans2")
plt.plot(t22,Fold2,'r',label="fold")
plt.plot(t22,Null2,'b',label="null")
#plt.legend(loc="lower left")
plt.ylabel("DL Probability")
plt.xlabel("Scaled Time")
plt.title("Van der Pol Oscillator - Hopf Bifurcation")
#plt.axvline(x=0.6,color='black',ls='--', ymin=0,ymax=1,label='Alpha=15.69')
plt.axvline(x=0.85,color='black',ls='--', ymin=0,ymax=1,label='Alpha=15.69')

X3 = time_series(3,0,1)
t31 = np.linspace(0,1,len(X3))

import statsmodels.api as sm
from scipy.ndimage import gaussian_filter1d
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from statsmodels.tsa.seasonal import seasonal_decompose
steps2 = len(X3)
steps = 1000
intervals = 400
sigmaa = 100
padding = 100
size = int(((steps2/steps)-1)*intervals)+1
Y = np.zeros((size,steps))
Y2 = np.zeros(steps+(2*padding))
t = np.zeros(size)
for i in range(0,size):
  j1=int(i*steps/intervals)
  j2 = j1+steps
  #j=i
  Y[i,:] = X3[j1:j2]
  #Y2[padding:steps+padding] = Y[i,:]
  #frac = 0.75
  Y[i,:] = Y[i,:]-(gaussian_filter1d(Y[i,:], sigmaa,mode = 'nearest'))
  #Y2[i,:] = Y[i,100:1100]
  #Y[i,:] = Y2[padding:steps+padding]
  Y[i,:] = (Y[i,:]-np.average(Y[i,:]))/(np.std(Y[i,:]))
  #Y2[i,:] = (Y2[i,:]-np.average(Y2[i,:]))/(np.std(Y2[i,:]))
  #smoothed = sm.nonparametric.lowess(Y[i,:], np.arange(len(Y[i,:])), frac=frac)
  #Y[i,:] = (Y[i,:]-smoothed[:,1])/(np.std(Y[i,:]-smoothed[:,1]))

np.shape(Y)
predict_x=model.predict(Y)
output=np.argmax(predict_x,axis=1)

import matplotlib.pyplot as plt
fold1_prob = predict_x[:,0]
#fold2_prob = predict_x[:,1]
Trans1_prob = predict_x[:,1]
#Trans2_prob = predict_x[:,3]
Hopf_prob = predict_x[:,2]
Null_prob = predict_x[:,3]
t= np.linspace(steps,steps2,size)
#t= t*50/size
plt.plot(t,fold1_prob,"r",label="fold")
#plt.plot(t,fold2_prob,"r",label="fold")
plt.plot(t,Trans1_prob,'g',label="trans1")
#plt.plot(t,Trans2_prob,'g',label="trans")
plt.plot(t,Hopf_prob,'y',label="Hopf")
plt.plot(t,Null_prob,'b',label="null")
#plt.plot(t,null_fold_prob,'y',label="Null_Fold")

plt.legend(loc="lower left")
plt.ylabel("DL Probability")
plt.xlabel("Time")
plt.axvline(x=0.7,color='black',ls='--', ymin=0,ymax=1,label='Alpha=0.55')

window_size = 50

Fold3 = np.convolve(fold1_prob, np.ones(window_size)/window_size, mode='valid')

Trans3 = np.convolve(Trans1_prob, np.ones(window_size)/window_size, mode='valid')
#Trans2_prob = np.convolve(Trans2_prob, np.ones(window_size)/window_size, mode='valid')
Hopf3 = np.convolve(Hopf_prob, np.ones(window_size)/window_size, mode='valid')
Null3 = np.convolve(Null_prob, np.ones(window_size)/window_size, mode='valid')

t32= np.linspace(0,1,np.size(Hopf3))
plt.plot(t32,Hopf3,"y",label="Hopf")
plt.plot(t32,Trans3,"g",label="Trans")
#plt.plot(t,Trans2_prob,"brown",label="Trans2")
plt.plot(t32,Fold3,'r',label="fold")
plt.plot(t32,Null3,'b',label="null")
#plt.legend(loc="lower left")
plt.ylabel("DL Probability")
plt.xlabel("Scaled Time")
plt.title("Van der Pol Oscillator - Hopf Bifurcation")
#plt.axvline(x=0.6,color='black',ls='--', ymin=0,ymax=1,label='Alpha=15.69')
plt.axvline(x=0.85,color='black',ls='--', ymin=0,ymax=1,label='Alpha=15.69')

from google.colab import files
import matplotlib.pyplot as plt

# Set global font size
plt.rcParams.update({'font.size': 14})

# Create a figure with 6 subplots in a vertical layout (time series on top, DL analysis below)
fig, axs = plt.subplots(2, 3, figsize=(20, 12), sharex=True, gridspec_kw={'width_ratios': [1, 1, 1]})

# Define labels for each subplot
subplot_labels = ['A', 'B', 'C', 'D', 'E', 'F']

# Top row: Time series
axs[0, 0].plot(t11, X1, label="Time Series 1")
axs[0, 0].set_title("Rosenzweig-MacArthur - Transcritical")
axs[0, 0].set_ylabel("State")
axs[0, 0].axvline(x=0.75, color='black', linestyle='--', linewidth=1)
axs[0, 0].text(0, 1.05, subplot_labels[0], transform=axs[0, 0].transAxes, fontsize=16, fontweight='bold')

axs[0, 1].plot(t21, X2, label="Time Series 2")
axs[0, 1].set_title("Rosenzweig-MacArthur - Hopf")
axs[0, 1].set_ylabel("State")
axs[0, 1].axvline(x=0.6, color='black', linestyle='--', linewidth=1)
axs[0, 1].text(0, 1.05, subplot_labels[1], transform=axs[0, 1].transAxes, fontsize=16, fontweight='bold')

axs[0, 2].plot(t31, X3, label="Time Series 3")
axs[0, 2].set_title("May's harvesting - Fold")
axs[0, 2].set_ylabel("State")
axs[0, 2].axvline(x=0.9, color='black', linestyle='--', linewidth=1)
axs[0, 2].text(0, 1.05, subplot_labels[2], transform=axs[0, 2].transAxes, fontsize=16, fontweight='bold')

# Bottom row: DL analysis results
axs[1, 0].plot(t12, Hopf1, color='darkgoldenrod', label="Hopf")
axs[1, 0].plot(t12, Trans1, color='green', label="Trans")
axs[1, 0].plot(t12, Fold1, color='red', label="Fold")
axs[1, 0].plot(t12, Null1, color='blue', label="Null")
axs[1, 0].set_title("DL Analysis - Transcritical")
axs[1, 0].set_ylabel("DL Probability")
axs[1, 0].axvline(x=0.75, color='black', linestyle='--', linewidth=1)
axs[1, 0].legend(loc='upper left')
axs[1, 0].text(0, 1.05, subplot_labels[3], transform=axs[1, 0].transAxes, fontsize=16, fontweight='bold')

axs[1, 1].plot(t22, Hopf2, color='darkgoldenrod', label="Hopf")
axs[1, 1].plot(t22, Trans2, color='green', label="Trans")
axs[1, 1].plot(t22, Fold2, color='red', label="Fold")
axs[1, 1].plot(t22, Null2, color='blue', label="Null")
axs[1, 1].set_title("DL Analysis - Hopf")
axs[1, 1].set_ylabel("DL Probability")
axs[1, 1].axvline(x=0.6, color='black', linestyle='--', linewidth=1)
axs[1, 1].legend(loc='upper left')
axs[1, 1].text(0, 1.05, subplot_labels[4], transform=axs[1, 1].transAxes, fontsize=16, fontweight='bold')

axs[1, 2].plot(t32, Hopf3, color='darkgoldenrod', label="Hopf")
axs[1, 2].plot(t32, Trans3, color='green', label="Trans")
axs[1, 2].plot(t32, Fold3, color='red', label="Fold")
axs[1, 2].plot(t32, Null3, color='blue', label="Null")
axs[1, 2].set_title("DL Analysis - Fold")
axs[1, 2].set_ylabel("DL Probability")
axs[1, 2].axvline(x=0.9, color='black', linestyle='--', linewidth=1)
axs[1, 2].legend(loc='upper left')
axs[1, 2].text(0, 1.05, subplot_labels[5], transform=axs[1, 2].transAxes, fontsize=16, fontweight='bold')

# Link x-axis across all plots
for ax in axs.flat:
    ax.set_xlabel("Scaled Time")

# Adjust layout
plt.tight_layout()
filename = "plot_with_labels.png"
fig.savefig(filename, dpi=300, bbox_inches="tight")

# Download the plot file
files.download(filename)
plt.show()