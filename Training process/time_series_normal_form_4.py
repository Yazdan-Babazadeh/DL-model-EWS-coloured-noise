# -*- coding: utf-8 -*-
"""Time_series_normal_form_4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BQem7yqM0ksqgJWWX3AbRX5UOrYy0MSG
"""

import numpy as np
import random
import matplotlib.pyplot as plt
import statsmodels.api as sm
from scipy.ndimage import gaussian_filter1d
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from statsmodels.tsa.seasonal import seasonal_decompose

Number_to_gather = 20000
Number_each = 5000
steps = 1000
dt = 10**-2
Time_series = np.zeros((Number_to_gather,steps))
Time_series2 = np.zeros((Number_to_gather,steps))
Label = np.zeros(Number_to_gather)
sigmaa = 100
redness = 0.5

def check_threshold(time_series, upper_threshold, lower_threshold):
    for value in time_series:
        if value > upper_threshold or value < lower_threshold:
            return 1  # Return 1 if any value exceeds the thresholds

    return 0

Number_fold = 0
Number_trans = 0
Number_hopf = 0
Number_null = 0
count = 0
count_blocked = 0
while Number_fold<Number_each or Number_trans<Number_each or Number_hopf<Number_each or Number_null < Number_each:
  R = int(random.uniform(0,4))
  if R == 0 and Number_fold < Number_each and random.uniform(0,1)<0.5:
    mu = random.uniform(-2,-3)
    c1 = 0 # random.uniform(-0.3,0.3)
    A = 10**(random.uniform(-1,-2)) # used to be -2 to -3
    X = np.zeros(steps)
    X[0] = - np.sqrt(np.abs(mu))
    delta_mu = (0-mu)/steps
    Red_noise=np.zeros(steps)
    Red_noise[0]=random.gauss(0,1)

    for i in range(0,steps-1):
      X[i+1] = X[i]+(((X[i]**2)+mu+(c1*(X[i]**3)))*dt) + (A*Red_noise[i]*np.sqrt(dt))
      Red_noise[i+1]= (redness*Red_noise[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
      mu = mu + delta_mu
    X = X-(gaussian_filter1d(X, sigmaa,mode = 'nearest'))
    X = (X-np.average(X))/(np.std(X))
    upper_threshold = np.mean(X) + (3*np.std(X))
    lower_threshold = np.mean(X) - (3*np.std(X))
    if check_threshold(X,upper_threshold,lower_threshold)==1:
      count_blocked = count_blocked + 1
      continue
    else:
      Time_series[count,:]= X
      Label[count] = 0
      count = count + 1
      Number_fold = Number_fold + 1
  ###########################################
  if R == 0 and Number_fold < Number_each and random.uniform(0,1)>0.5:
    mu = random.uniform(2,3)
    c1 = 0 # random.uniform(-0.3,0.3)
    A = 10**(random.uniform(-1,-2)) # used to be -2 to -3
    X = np.zeros(steps)
    X[0] =  np.sqrt(np.abs(mu))
    delta_mu = (0-mu)/steps
    Red_noise=np.zeros(steps)
    Red_noise[0]=random.gauss(0,1)

    for i in range(0,steps-1):
      X[i+1] = X[i]+((-(X[i]**2)+mu+(c1*(X[i]**3)))*dt) + (A*Red_noise[i]*np.sqrt(dt))
      Red_noise[i+1]= (redness*Red_noise[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
      mu = mu + delta_mu
    X = X-(gaussian_filter1d(X, sigmaa,mode = 'nearest'))
    X = (X-np.average(X))/(np.std(X))
    upper_threshold = np.mean(X) + (3*np.std(X))
    lower_threshold = np.mean(X) - (3*np.std(X))
    if check_threshold(X,upper_threshold,lower_threshold)==1:
      count_blocked = count_blocked + 1
      continue
    else:
      Time_series[count,:]= X
      Label[count] = 0
      count = count + 1
      Number_fold = Number_fold + 1
################################################ transcritical 1 #################

  if R ==1 and Number_trans < Number_each and int(random.uniform(0,4))==0 :
    mu = random.uniform(-2,-3) #-2 to -3
    c1 = 0 # random.uniform(-0.3,0.3)
    A = 10**(random.uniform(-1,-2)) # used to be -2 to -3
    X = np.zeros(steps)
    X[0] = 0
    delta_mu = (0-mu)/steps
    Red_noise=np.zeros(steps)
    Red_noise[0]=random.gauss(0,1)


    for i in range(0,steps-1):
      X[i+1] = X[i]+((-(X[i]**2)+(mu*X[i])+(c1*(X[i]**3)))*dt) + (A*Red_noise[i]*np.sqrt(dt))
      Red_noise[i+1]= (redness*Red_noise[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
      mu = mu + delta_mu
    X = X-(gaussian_filter1d(X, sigmaa,mode = 'nearest'))
    X = (X-np.average(X))/(np.std(X))
    upper_threshold = np.mean(X) + (3*np.std(X))
    lower_threshold = np.mean(X) - (3*np.std(X))
    if check_threshold(X,upper_threshold,lower_threshold)==1:
      count_blocked = count_blocked + 1
      continue
    else:
      Time_series[count,:]= X
      Label[count] = 1
      count = count + 1
      Number_trans = Number_trans + 1
  ############################################# transcritical 2 ##################
  if R ==1 and Number_trans < Number_each and int(random.uniform(0,4))==1  :
    mu = random.uniform(-2,-3) #2,3
    c1 = 0 # random.uniform(-0.3,0.3)
    A = 10**(random.uniform(-1,-2)) # used to be -2 to -3
    X = np.zeros(steps)
    X[0] = 0
    delta_mu = (0-mu)/steps
    Red_noise=np.zeros(steps)
    Red_noise[0]=random.gauss(0,1)

    for i in range(0,steps-1):
      X[i+1] = X[i]+(((X[i]**2)+(mu*X[i])+(c1*(X[i]**3)))*dt) + (A*Red_noise[i]*np.sqrt(dt))
      Red_noise[i+1]= (redness*Red_noise[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
      mu = mu + delta_mu
    X = X-(gaussian_filter1d(X, sigmaa,mode = 'nearest'))
    X = (X-np.average(X))/(np.std(X))
    upper_threshold = np.mean(X) + (3*np.std(X))
    lower_threshold = np.mean(X) - (3*np.std(X))
    if check_threshold(X,upper_threshold,lower_threshold)==1:
      count_blocked = count_blocked + 1
      continue
    else:
      Time_series[count,:]= X
      Label[count] = 1
      count = count + 1
      Number_trans = Number_trans + 1

###############################################
  if R ==1 and Number_trans < Number_each and int(random.uniform(0,4))==2 :
    mu = random.uniform(2,3) #-2,-3
    c1 = 0 # random.uniform(-0.3,0.3)
    A = 10**(random.uniform(-1,-2)) # used to be -2 to -3
    X = np.zeros(steps)
    X[0] = 0
    delta_mu = (0-mu)/steps
    Red_noise=np.zeros(steps)
    Red_noise[0]=random.gauss(0,1)

    for i in range(0,steps-1):
      X[i+1] = X[i]+(((X[i]**2)+(-mu*X[i])+(c1*(X[i]**3)))*dt) + (A*Red_noise[i]*np.sqrt(dt))
      Red_noise[i+1]= (redness*Red_noise[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
      mu = mu + delta_mu
    X = X-(gaussian_filter1d(X, sigmaa,mode = 'nearest'))
    X = (X-np.average(X))/(np.std(X))
    upper_threshold = np.mean(X) + (3*np.std(X))
    lower_threshold = np.mean(X) - (3*np.std(X))
    if check_threshold(X,upper_threshold,lower_threshold)==1:
      count_blocked = count_blocked + 1
      continue
    else:
      Time_series[count,:]= X
      Label[count] = 1
      count = count + 1
      Number_trans = Number_trans + 1
#####################################################
  if R ==1 and Number_trans < Number_each and int(random.uniform(0,4))==3 :
    mu = random.uniform(2,3) #-2,-3
    c1 = 0 # random.uniform(-0.3,0.3)
    A = 10**(random.uniform(-1,-2)) # used to be -2 to -3
    X = np.zeros(steps)
    X[0] = 0
    delta_mu = (0-mu)/steps
    Red_noise=np.zeros(steps)
    Red_noise[0]=random.gauss(0,1)

    for i in range(0,steps-1):
      X[i+1] = X[i]+((-(X[i]**2)+(-mu*X[i])+(c1*(X[i]**3)))*dt) + (A*Red_noise[i]*np.sqrt(dt))
      Red_noise[i+1]= (redness*Red_noise[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
      mu = mu + delta_mu
    X = X-(gaussian_filter1d(X, sigmaa,mode = 'nearest'))
    X = (X-np.average(X))/(np.std(X))
    upper_threshold = np.mean(X) + (3*np.std(X))
    lower_threshold = np.mean(X) - (3*np.std(X))
    if check_threshold(X,upper_threshold,lower_threshold)==1:
      count_blocked = count_blocked + 1
      continue
    else:
      Time_series[count,:]= X
      Label[count] = 1
      count = count + 1
      Number_trans = Number_trans + 1
######################################################################
  if R ==2 and Number_hopf < Number_each:
    Y = np.zeros(steps)
    X = np.zeros(steps)
    beta = random.uniform(-1,-0.7) #-0.2,-0.05
    A = 10**(random.uniform(-1,-2))
    X[0] = 0
    Y[0] = 0
    delta_beta = (0.1-beta)/steps
    Red_noise1=np.zeros(steps)
    Red_noise1[0]=random.gauss(0,1)

    Red_noise2=np.zeros(steps)
    Red_noise2[0]=random.gauss(0,1)

    for i in range(0,steps-1):
      X[i+1] = X[i]+(-Y[i] + (X[i]*(beta-(X[i]**2)-(Y[i]**2))))*dt +(np.sqrt(dt)*Red_noise1[i]*A)
      Y[i+1] = Y[i]+(X[i] + (Y[i]*(beta-(X[i]**2)-(Y[i]**2))))*dt + (np.sqrt(dt)*Red_noise2[i]*A)
      Red_noise1[i+1]= (redness*Red_noise1[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
      Red_noise2[i+1]= (redness*Red_noise2[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
      beta = beta + delta_beta
    X = X-(gaussian_filter1d(X, sigmaa,mode = 'nearest'))
    X = (X-np.average(X))/(np.std(X))
    upper_threshold = np.mean(X) + (3*np.std(X))
    lower_threshold = np.mean(X) - (3*np.std(X))
    if check_threshold(X,upper_threshold,lower_threshold)==1:
      count_blocked = count_blocked + 1
      continue
    else:
      Time_series[count,:]= X
      Label[count] = 2
      count = count + 1
      Number_hopf = Number_hopf + 1

#################################################
  if R==3 and Number_null<Number_each:
    A = 10**(random.uniform(-1,-2)) # used to be -2 to -3
    X = np.zeros(steps)
    X[0] = 0
    Red_noise=np.zeros(steps)
    Red_noise[0]=random.gauss(0,1)
    for i in range(0,steps-1):
      X[i+1] = X[i] + (A*Red_noise[i]*np.sqrt(dt))
      Red_noise[i+1]= (redness*Red_noise[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
    X = X-(gaussian_filter1d(X, sigmaa,mode = 'nearest'))
    X = (X-np.average(X))/(np.std(X))
    Time_series[count,:]= X
    Label[count] = 3
    count = count + 1
    Number_null = Number_null + 1
    """
    RR = int(random.uniform(0,3))
    if RR ==0:
        c1 = 0
        mu = random.uniform(-7,-5) #-20,-30
        A = 10**(random.uniform(-1,-2)) # used to be -2 to -3
        X = np.zeros(steps)
        X[0] = - np.sqrt(np.abs(mu))
        for i in range(0,steps-1):
          X[i+1] = X[i]+(((X[i]**2)+mu+(c1*(X[i]**3)))*dt) + (A*random.gauss(0,1)*np.sqrt(dt))
        X = X-(gaussian_filter1d(X, sigmaa,mode = 'nearest'))
        X = (X-np.average(X))/(np.std(X))
        Time_series[count,:]= X
        Label[count] = 3
        count = count + 1
        Number_null = Number_null + 1
    elif RR == 1:
        mu = random.uniform(-7,-5)
        c1 = 0 # random.uniform(-0.3,0.3)
        A = 10**(random.uniform(-1,-2)) # used to be -2 to -3
        X = np.zeros(steps)
        X[0] = 0
        for i in range(0,steps-1):
          X[i+1] = X[i]+((-(X[i]**2)+(mu*X[i])+(c1*(X[i]**3)))*dt) + (A*random.gauss(0,1)*np.sqrt(dt))
        X = X-(gaussian_filter1d(X, sigmaa,mode = 'nearest'))
        X = (X-np.average(X))/(np.std(X))
        Time_series[count,:]= X
        Label[count] = 3
        count = count + 1
        Number_null = Number_null + 1
    elif RR == 2:
        Y = np.zeros(steps)
        X = np.zeros(steps)
        beta = random.uniform(-7,-5) #-0.2,-0.05
        A = 10**(random.uniform(-1,-2))
        X[0] = 0
        Y[0] = 0

        for i in range(0,steps-1):
          X[i+1] = X[i]+(-Y[i] + (X[i]*(beta-(X[i]**2)-(Y[i]**2))))*dt +(np.sqrt(dt)*random.gauss(0,1)*A)
          Y[i+1] = Y[i]+(X[i] + (Y[i]*(beta-(X[i]**2)-(Y[i]**2))))*dt +(np.sqrt(dt)*random.gauss(0,1)*A)
        X = X-(gaussian_filter1d(X, sigmaa,mode = 'nearest'))
        X = (X-np.average(X))/(np.std(X))
        Time_series[count,:]= X
        Label[count] = 3
        count = count + 1
        Number_null = Number_null + 1
      """

  #############################################

count_blocked

num_rows = Time_series.shape[0]

# Create an array of indices and shuffle it
indices = np.arange(num_rows)
np.random.shuffle(indices)

# Use the shuffled indices to shuffle rows in A and B
Time_series_shuffled = Time_series[indices, :]
Label_shuffled = Label[indices]



np.save('Label.npy', Label_shuffled)
from google.colab import files
files.download('Label.npy')

np.save('Time_series.npy', Time_series_shuffled)
from google.colab import files
files.download('Time_series.npy')

n = 90
plt.plot(Time_series_shuffled[n,:])
Label_shuffled[n]

Label