# -*- coding: utf-8 -*-
"""ROC curve.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OXycv7vh4fxXIfhKBOCP0jiAsYjz5heN
"""

import numpy as np
import random
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from scipy.ndimage import gaussian_filter1d
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
import statsmodels.api as sm
from statsmodels.tsa.seasonal import seasonal_decompose
from tensorflow.keras.models import load_model
import warnings
warnings.filterwarnings("ignore", category=UserWarning, module='tensorflow')

from multiprocessing import Pool
from joblib import Parallel, delayed

from tqdm import tqdm

# Get user inputs for index and redness
index = int(input("Enter the value for index (1: Trans, 2: Hopf, 3: Fold, 4: Trans, 5: Hopf, 6: Fold): "))
redness = float(input("Enter the value for redness (e.g., 0.1, 0.2, ... 0.5): "))


def time_series(index,redness,on): #1:Trans, 2:Hopf, 3: fold # 4:Trans 5:Hopf 6:Fold
  if index == 1:
    T = 200
    dt = (10**-2)
    steps2= int(T/dt)

    r=4
    k=1.7
    e=0.5
    h=0.15

    m=2


    def X_trans_dot(x,y,a):
      a1 = r*x*(1-(x/k))
      b1 = (a*x*y)/(1+(a*h*x))
      return a1-b1
    def Y_trans_dot(x,y,a):
      a1 = (e*a*x*y)/(1+(a*h*x))
      b1 = m*y
      return a1-b1
    a = -2

    #for transcritical -2 to 6
    #for hopf 12 to 18
    X=np.zeros(steps2)
    Y = np.zeros(steps2)
    X[0]=2
    Y[0]=2
    for i in range(0,steps2-1):
      X[i+1] = X[i] + (X_trans_dot(X[i],Y[i],a))*dt
      Y[i+1] = Y[i] + (Y_trans_dot(X[i],Y[i],a))*dt
    #plt.plot(X)
    #plt.plot(Y)

    X2 = np.zeros(steps2)
    Y2 = np.zeros(steps2)
    if on == 1:
      da = (6-a)/(steps2) #9
    else:
      da = 0
    #bifurcation happens at a=5.6
    X2[0] = X[steps2-1]
    Y2[0] = Y[steps2-1]
    sigma = 0.01 #0.005
    Red_noise5 = np.zeros(steps2)
    Red_noise5[0] = random.gauss(0,1)
    for i in range(0,steps2-1):
      a = a + da
      X2[i+1] = X2[i] + (X_trans_dot(X2[i],Y2[i],a)*dt) + (sigma*np.sqrt(dt)*Red_noise5[i])
      Y2[i+1] = Y2[i] + (Y_trans_dot(X2[i],Y2[i],a)*dt) + (sigma*np.sqrt(dt)*Red_noise5[i])
      Red_noise5[i+1]= (redness*Red_noise5[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
    #X2 = 1-X2
    return X2
  elif index == 2:
    T = 200
    dt = (10**-2)
    steps2= int(T/dt)

    r=4
    k=1.7
    e=0.5
    h=0.15

    m=2
    redness = 0

    def X_trans_dot(x,y,a):
      a1 = r*x*(1-(x/k))
      b1 = (a*x*y)/(1+(a*h*x))
      return a1-b1
    def Y_trans_dot(x,y,a):
      a1 = (e*a*x*y)/(1+(a*h*x))
      b1 = m*y
      return a1-b1
    a = 9

    #for transcritical -2 to 6
    #for hopf 12 to 18
    X=np.zeros(steps2)
    Y = np.zeros(steps2)
    X[0]=2
    Y[0]=2
    for i in range(0,steps2-1):
      X[i+1] = X[i] + (X_trans_dot(X[i],Y[i],a))*dt
      Y[i+1] = Y[i] + (Y_trans_dot(X[i],Y[i],a))*dt
    #plt.plot(X)
    #plt.plot(Y)

    X2 = np.zeros(steps2)
    Y2 = np.zeros(steps2)
    if on == 1:
      da = (18-a)/(steps2) #9
    else:
      da = 0
    #bifurcation happens at a=5.6
    X2[0] = X[steps2-1]
    Y2[0] = Y[steps2-1]
    sigma = 0.01 #0.005
    Red_noise5 = np.zeros(steps2)
    Red_noise5[0] = random.gauss(0,1)
    for i in range(0,steps2-1):
      a = a + da
      X2[i+1] = X2[i] + (X_trans_dot(X2[i],Y2[i],a)*dt) + (sigma*np.sqrt(dt)*Red_noise5[i])
      Y2[i+1] = Y2[i] + (Y_trans_dot(X2[i],Y2[i],a)*dt) + (sigma*np.sqrt(dt)*Red_noise5[i])
      Red_noise5[i+1]= (redness*Red_noise5[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
    return X2
  elif index==3:

    T1 = 100
    dt1 = (10**-2)
    test_steps1= int(T1/dt1)
    steps2 = test_steps1

    def X_fold_dot(x,h):
      a = x*(1-x)
      b = h * ((x**2)/((x**2)+(0.01)))
      return a-b
    t1 = np.linspace(0,T1,test_steps1)
    x = odeint(X_fold_dot,random.uniform(15,20),t1)

    #plt.plot(x)
    h = 0.2   #0.1
    if on == 1:
      dh = (0.29-h)/test_steps1
    else :
      dh = 0
    #bifurcation happens at h=0.26

    #dh = (0.5-h)/(test_steps1)
    X_fold = np.zeros(test_steps1)
    #X_fold[0] = x[test_steps1-1]
    X_fold[0] = 0.7
    Red_noise = np.zeros(test_steps1)
    Red_noise[0] = random.gauss(0,1)
    for i in range(0,test_steps1-1):
      Red_noise[i+1]= (redness*Red_noise[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
      h = h + dh
      X_fold[i+1] = X_fold[i] + (X_fold_dot(X_fold[i],h)*dt1) + (0.01*np.sqrt(dt1)*random.gauss(0,1))#Red_noise[i+1]) #uused to be 0.01
    return X_fold
  elif index == 4:
    steps = 10000
    I = np.zeros(steps)
    gamma = 5
    beta = 0
    if on ==1:
      d_beta = (5-beta)/steps
    else:
      d_beta = 0
    I[0] = 0
    dt = 10**-2
    def I_dot(i,beta):
      a = beta*i*(1-i)
      b = gamma*i
      return a-b
    sigma = 0.01
    Red_noise = np.zeros(steps)
    Red_noise[0] = random.gauss(0,1)
    for i in range(0,steps-1):
      I[i+1] = I[i] + I_dot(I[i],beta)*dt + sigma*np.sqrt(dt)*Red_noise[i]
      Red_noise[i+1]= (redness*Red_noise[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
      beta = beta + d_beta
    return I
  elif index ==5:
    steps = 10000
    dt = 10**-2
    X = np.zeros(steps)
    Y = np.zeros(steps)
    X[0] = 0
    Y[0] = 0

    def x_dot(x,y,mu):
        return y
    def y_dot(x,y,mu):
        return mu*(1-x**2)*y-x

    mu = -5.0
    if on == 1:
      d_mu = (1-mu)/steps
    else:
      d_mu = 0
    sigma = 0.1
    Red_noise1 = np.zeros(steps)
    Red_noise1[0] = random.gauss(0,1)
    Red_noise2 = np.zeros(steps)
    Red_noise2[0] = random.gauss(0,1)
    for i in range(0,steps-1):
        X[i+1] = X[i] + x_dot(X[i],Y[i],mu)*dt + (sigma*np.sqrt(dt)*Red_noise1[i])
        Y[i+1] = Y[i] + y_dot(X[i],Y[i],mu)*dt + (sigma*np.sqrt(dt)*Red_noise2[i])
        Red_noise1[i+1]= (redness*Red_noise1[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
        Red_noise2[i+1]= (redness*Red_noise2[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
        mu = mu + d_mu
    return X
  else:
    def u_dot(u,r):
      a = -u
      b = r/(1+np.exp(-5*(u-1)))
      return a+b

    steps = 10000
    u = np.zeros(steps)
    u[0] = 5
    r = 5
    if on == 1:
      dr = (1-r)/steps
    else:
      dr = 0
    dt = 0.01
    sigma = 0.1
    Red_noise = np.zeros(steps)
    Red_noise[0] = random.gauss(0,1)
    for i in range(steps-1):
      u[i+1] = u[i] + u_dot(u[i],r)*dt + sigma*Red_noise[i]*np.sqrt(dt)
      Red_noise[i+1]= (redness*Red_noise[i]) + (np.sqrt((1-(redness**2)))*random.gauss(0,1))
      r = r + dr
    return u




def preproccesing(X):
      steps2 = len(X)
      steps = 1000
      intervals = 400
      sigmaa = 100
      padding = 100
      size = int(((steps2 / steps) - 1) * intervals) + 1
      Y = np.zeros((size, steps))
      Y2 = np.zeros(steps + (2 * padding))
      t = np.zeros(size)
      for i in range(0, size):
          j1 = int(i * steps / intervals)
          j2 = j1 + steps
          # j=i
          Y[i, :] = X[j1:j2]
          # Y2[padding:steps+padding] = Y[i,:]
          # frac = 0.75
          Y[i, :] = Y[i, :] - (gaussian_filter1d(Y[i, :], sigmaa, mode='nearest'))
          # Y2[i,:] = Y[i,100:1100]
          # Y[i,:] = Y2[padding:steps+padding]
          Y[i, :] = (Y[i, :] - np.average(Y[i, :])) / (np.std(Y[i, :]))
          # Y2[i,:] = (Y2[i,:]-np.average(Y2[i,:]))/(np.std(Y2[i,:]))
          # smoothed = sm.nonparametric.lowess(Y[i,:], np.arange(len(Y[i,:])), frac=frac)
          # Y[i,:] = (Y[i,:]-smoothed[:,1])/(np.std(Y[i,:]-smoothed[:,1]))

      return Y

def DL(Y, on, redness):
  model_base = load_model('Normal_form_CNN_LSTM_r=0.h5')
  if redness == 0.1:
      model = load_model('Normal_form_CNN_LSTM_r=0.1.h5')
  elif redness == 0.2:
      model = load_model('Normal_form_CNN_LSTM_r=0.2.h5')
  elif redness == 0.3:
      model = load_model('Normal_form_CNN_LSTM_r=0.3.h5')
  elif redness == 0.4:
      model = load_model('Normal_form_CNN_LSTM_r=0.4.h5')
  elif redness == 0.5:
      model = load_model('Normal_form_CNN_LSTM_r=0.5.h5')
  else:
      raise ValueError("Redness value is not supported.")

  if on == 1:
      predict_x = model_base.predict(Y)
  else:
      predict_x = model.predict(Y)

  fold_prob = predict_x[:, 0]
  Trans_prob = predict_x[:, 1]
  Hopf_prob = predict_x[:, 2]
  Null_prob = predict_x[:, 3]

  return fold_prob, Trans_prob, Hopf_prob, Null_prob

def postproccesing(fold_prob,Trans_prob,Hopf_prob,Null_prob,index):
  if index == 4:
    window_size = 100
  else:
    window_size = 400
  fold_prob = np.convolve(fold_prob, np.ones(window_size)/window_size, mode='valid')
  Trans_prob = np.convolve(Trans_prob, np.ones(window_size)/window_size, mode='valid')
  Hopf_prob = np.convolve(Hopf_prob, np.ones(window_size)/window_size, mode='valid')
  Null_prob = np.convolve(Null_prob, np.ones(window_size)/window_size, mode='valid')
  return fold_prob,Trans_prob,Hopf_prob,Null_prob


def classifier(X,threshold,index):
  if index == 1:
    if np.mean(X)>threshold:
      return 1
    else:
      return 0
  elif index==2:
    if np.mean(X)>threshold:
      return 1
    else:
      return 0
  elif index ==3:
    if max(X)-min(X)>threshold:
      return 1
    else:
      return 0
  elif index == 4:
    if np.mean(X)>threshold:
      return 1
    else:
      return 0
  elif index == 5:
    if np.mean(X)>threshold:
      return 1
    else:
      return 0
  else:
    if max(X)-min(X)>threshold:
      return 1
    else:
      return 0


repeat = 50


def process_data(r, index, redness):
  # Load the models
  number_threshold = 200
  Threshold = np.linspace(0, 1, number_threshold)

  TPR0 = np.zeros(number_threshold)
  FPR0 = np.zeros(number_threshold)
  TPR1 = np.zeros(number_threshold)
  FPR1 = np.zeros(number_threshold)

  # Model 1, not_null 1
  not_null = 1
  model_index = 1
  fold_prob, Trans_prob, Hopf_prob, Null_prob = DL(preproccesing(time_series(index, redness, not_null)), model_index, redness)
  Fold_prob, Trans_prob, Hopf_prob, Null_prob = postproccesing(fold_prob, Trans_prob, Hopf_prob, Null_prob,index)

  if index == 1 or index == 4:
      X = Trans_prob
  elif index == 2 or index == 5:
      X = Hopf_prob
  elif index == 3 or index == 6:
      X = Fold_prob
  else:
      X = Null_prob

  for count, threshold in enumerate(Threshold):
      TPR0[count] += classifier(X, threshold,index)

  # Model 1, not_null 0
  model_index = 1
  not_null = 0
  fold_prob, Trans_prob, Hopf_prob, Null_prob = DL(preproccesing(time_series(index, redness, not_null)), model_index, redness)
  Fold_prob, Trans_prob, Hopf_prob, Null_prob = postproccesing(fold_prob, Trans_prob, Hopf_prob, Null_prob,index)

  if index == 1 or index == 4:
      X = Trans_prob
  elif index == 2 or index == 5:
      X = Hopf_prob
  elif index == 3 or index == 6:
      X = Fold_prob
  else:
      X = Null_prob

  for count, threshold in enumerate(Threshold):
      FPR0[count] += classifier(X, threshold,index)

  # Model 0, not_null 1
  model_index = 0
  not_null = 1
  fold_prob, Trans_prob, Hopf_prob, Null_prob = DL(preproccesing(time_series(index, redness, not_null)), model_index, redness)
  Fold_prob, Trans_prob, Hopf_prob, Null_prob = postproccesing(fold_prob, Trans_prob, Hopf_prob, Null_prob,index)

  if index == 1 or index == 4:
      X = Trans_prob
  elif index == 2 or index == 5:
      X = Hopf_prob
  elif index == 3 or index == 6:
      X = Fold_prob
  else:
      X = Null_prob

  for count, threshold in enumerate(Threshold):
      TPR1[count] += classifier(X, threshold,index)

  # Model 0, not_null 0
  model_index = 0
  not_null = 0
  fold_prob, Trans_prob, Hopf_prob, Null_prob = DL(preproccesing(time_series(index, redness, not_null)), model_index, redness)
  Fold_prob, Trans_prob, Hopf_prob, Null_prob = postproccesing(fold_prob, Trans_prob, Hopf_prob, Null_prob,index)

  if index == 1 or index == 4:
      X = Trans_prob
  elif index == 2 or index == 5:
      X = Hopf_prob
  elif index == 3 or index == 6:
      X = Fold_prob
  else:
      X = Null_prob

  for count, threshold in enumerate(Threshold):
      FPR1[count] += classifier(X, threshold,index)
  return TPR0, FPR0, TPR1, FPR1

def aggregate_results(results):
  TPR0_total = np.sum([result[0] for result in results], axis=0)
  FPR0_total = np.sum([result[1] for result in results], axis=0)
  TPR1_total = np.sum([result[2] for result in results], axis=0)
  FPR1_total = np.sum([result[3] for result in results], axis=0)
  return TPR0_total, FPR0_total, TPR1_total, FPR1_total

repeat_t = np.arange(0, repeat, 1)
results = Parallel(n_jobs=-1)(delayed(process_data)(r, index, redness) for r in repeat_t)

#with Pool() as pool:
#    results = list(tqdm(pool.imap(process_data, repeat_t), total=len(repeat_t)))
TPR0_total, FPR0_total, TPR1_total, FPR1_total = aggregate_results(results)

TPR0 = TPR0_total/repeat
FPR0 = FPR0_total/repeat
TPR1 = TPR1_total/repeat
FPR1 = FPR1_total/repeat

# Save the results
fpr0_filename = 'FPR0.txt'
tpr0_filename = 'TPR0.txt'
fpr1_filename = 'FPR1.txt'
tpr1_filename = 'TPR1.txt'

np.savetxt(fpr0_filename, FPR0, delimiter=',')
np.savetxt(tpr0_filename, TPR0, delimiter=',')
np.savetxt(fpr1_filename, FPR1, delimiter=',')
np.savetxt(tpr1_filename, TPR1, delimiter=',')



from sklearn.metrics import auc

def plot_roc_curve(x1, y1, x2, y2, index, redness):
    # Set the name based on the index
    name = {1: "Rosenzweig−MacArthur consumer−resource - Transcritical", 2: "Rosenzweig−MacArthur consumer−resource - Hopf", 3: "May's harvesting - Fold", 4: "SIS - Transcritical", 5: "Van der pole - Hopf", 6: "Neural Activation - Fold" }.get(index, "Unknown")

    # Calculate AUC for both classifiers
    auc1 = auc(x1, y1)
    auc2 = auc(x2, y2)

    # Plot the ROC curves
    plt.figure()
    plt.plot(x1, y1, label=f'WhiteNoise-Trained Classifier (AUC = {auc1:.2f})')
    plt.plot(x2, y2, label=f'RedNoise-Trained Classifier (AUC = {auc2:.2f})')
    plt.plot([0, 1], [0, 1], 'k--')  # Diagonal line for random classifier

    # Title and labels
    plt.title(f'ROC curve of {name} for redness of {redness}')
    plt.xlabel('False Positive Rate')
    plt.ylabel('True Positive Rate')

    # Legend in the bottom right
    plt.legend(loc='lower right')

    # Show the plot
    plt.show()
    filename = f"{name}_{redness}.png"
    plt.savefig(filename)


plot_roc_curve(FPR0, TPR0, FPR1, TPR1, index, redness)